let dragShapes = [];
let targetShape = "";
let draggedShape = null;
let feedbackMsg = "";
let feedbackColor = "#000";
let feedbackTimer = 0;
let dragScore = 0;
let shapeList = ["circle", "square", "triangle", "star", "heart"];
let gameWon = false;

function startShapeDragGame() {
  dragShapes = [];
  for (let i = 0; i < shapeList.length; i++) {
    dragShapes.push({
      type: shapeList[i],
      x: 120 + i * 90,
      y: 180,
      size: 70,
      color: color(random(100, 255), random(100, 255), random(100, 255))
    });
  }
  targetShape = random(shapeList);
  draggedShape = null;
  feedbackMsg = "";
  feedbackTimer = 0;
  gameWon = false;
}

function drawShapeDragGame() {
  drawGarden();
  textAlign(CENTER);
  textFont(fontRegular);
  fill("#7a0043");
  textSize(32);
  text("üü£ Shape Drag & Drop üü£", width / 2, 60);

  textSize(20);
  fill("#7a0043");
  text(`Score: ${dragScore}`, width - 70, 40);

  if (gameWon) {
    textSize(40);
    fill("green");
    text("üéâ You Won! üéâ", width / 2, height / 2);
    textSize(20);
    fill("#7a0043");
    text("Click Return to Home to play again!", width / 2, height / 2 + 40);
    drawBackButton();
    return;
  }

  // Target box
  fill("#fff6f8");
  stroke("#ff8ba0");
  strokeWeight(3);
  rectMode(CENTER);
  rect(width / 2, height - 80, 180, 100, 20);
  noStroke();
  fill("#7a0043");
  textSize(20);
  text("Drop the " + targetShape + " here!", width / 2, height - 120);

  // Draw shapes
  for (let s of dragShapes) drawShape(s);

  // Feedback
  if (feedbackTimer > 0) {
    fill(feedbackColor);
    textSize(24);
    text(feedbackMsg, width / 2, 120);
    feedbackTimer--;
  }
  drawBackButton();
}

function drawShape(s) {
  noStroke();
  fill(s.color);
  if (s.type === "circle") ellipse(s.x, s.y, s.size);
  else if (s.type === "square")
    rectMode(CENTER), rect(s.x, s.y, s.size, s.size, 10);
  else if (s.type === "triangle")
    triangle(
      s.x,
      s.y - s.size / 2,
      s.x - s.size / 2,
      s.y + s.size / 2,
      s.x + s.size / 2,
      s.y + s.size / 2
    );
  else if (s.type === "star") drawStar(s.x, s.y, s.size / 3, s.size / 1.2, 5);
  else if (s.type === "heart") drawHeart(s.x, s.y, s.size);
}

function drawStar(x, y, r1, r2, n) {
  let angle = TWO_PI / n, half = angle / 2;
  beginShape();
  for (let a = 0; a < TWO_PI; a += angle) {
    vertex(x + cos(a) * r2, y + sin(a) * r2);
    vertex(x + cos(a + half) * r1, y + sin(a + half) * r1);
  }
  endShape(CLOSE);
}

function drawHeart(x, y, s) {
  beginShape();
  vertex(x, y + s / 4);
  bezierVertex(x - s / 2, y - s / 2, x - s, y + s / 3, x, y + s);
  bezierVertex(x + s, y + s / 3, x + s / 2, y - s / 2, x, y + s / 4);
  endShape(CLOSE);
}

function mouseDragged() {
  if (screen === "dragdrop" && draggedShape) {
    draggedShape.x = mouseX;
    draggedShape.y = mouseY;
  }
}

function mouseReleased() {
  if (screen === "dragdrop" && draggedShape && !gameWon) {
    let box = { x: width / 2, y: height - 80, w: 180, h: 100 };
    if (
      mouseX > box.x - box.w / 2 &&
      mouseX < box.x + box.w / 2 &&
      mouseY > box.y - box.h / 2 &&
      mouseY < box.y + box.h / 2
    ) {
      if (draggedShape.type === targetShape) {
        dragScore++;
        feedbackMsg = "‚úÖ Great job!";
        feedbackColor = "green";
        feedbackTimer = 120;

        if (dragScore >= 10) {
          gameWon = true;
        } else {
          targetShape = random(shapeList);
        }
      } else {
        feedbackMsg = "‚ùå Try again!";
        feedbackColor = "red";
        feedbackTimer = 120;
      }
    }
    draggedShape = null;
  }
}

function mousePressed() {
  if (screen === "dragdrop") {
    for (let s of dragShapes) {
      if (isMouseOverShape(s)) {
        draggedShape = s;
        break;
      }
    }
  }
}

function isMouseOverShape(s) {
  if (s.type === "circle") return dist(mouseX, mouseY, s.x, s.y) < s.size / 2;
  else if (s.type === "square")
    return (
      mouseX > s.x - s.size / 2 &&
      mouseX < s.x + s.size / 2 &&
      mouseY > s.y - s.size / 2 &&
      mouseY < s.y + s.size / 2
    );
  else return dist(mouseX, mouseY, s.x, s.y) < s.size / 1.2;
}
