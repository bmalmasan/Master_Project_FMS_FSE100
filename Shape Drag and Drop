// ----------------------
// ðŸŸ£ Shape Drag & Drop Game
// ----------------------
function shuffleArray(arr) {
    let a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
        let j = floor(random(i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}

function startShapeDragGame() {
    // Hide completion buttons in case they exist
    hideCompletionButtons();

    dragShapes = [];
    let startX = 120;
    let spacing = 90;

    for (let i = 0; i < shapeList.length; i++) {
        let s = {
            type: shapeList[i],
            x: startX + i * spacing,
            y: 180,
            homeX: startX + i * spacing,
            homeY: 180,
            size: 70,
            color: color(random(100, 255), random(100, 255), random(100, 255)),
            returning: false,
            shakeTimer: 0,
            locked: false
        };
        dragShapes.push(s);
    }

    targetsQueue = shuffleArray(shapeList);
    targetShape = targetsQueue.length ? targetsQueue[0] : "";
    draggedShape = null;
    feedbackMsg = "";
    feedbackTimer = 0;
    correctAttempts = 0;
    totalAttempts = 0;
    gameFinished = false;

    // Make sure screen and DOM buttons are consistent
    screen = "dragdrop";
    for (let k in buttons) buttons[k].hide();
    hideCompletionButtons();
}

function drawShapeDragGame() {
    drawGarden();

    textAlign(CENTER);
    textFont(fontRegular);
    fill("#7a0043");
    textSize(32);
    text("ðŸŸ£ Shape Drag & Drop ðŸŸ£", width / 2, 60);
    textSize(18);
    fill("#7a0043");
    text(`Correct: ${correctAttempts} / Attempts: ${totalAttempts}`, width - 300, 90);

    // Update & draw shapes
    for (let s of dragShapes) updateShapeAnimation(s);
    for (let s of dragShapes) drawShape(s);

    // Target box
    fill("#fff6f8"); stroke("#ff8ba0"); strokeWeight(3);
    rectMode(CENTER);
    rect(width / 2, height - 80, 180, 100, 20);
    noStroke(); fill("#7a0043"); textSize(20);
    text((targetShape || "") + " here! --->", width / 4.5, height - 80);

    // Feedback
    if (feedbackTimer > 0) {
        fill(feedbackColor);
        textSize(24);
        text(feedbackMsg, width / 2, 120);
        feedbackTimer--;
    }

    drawBackButton();
}

// ----------------------
// Shape Animations
// ----------------------
function updateShapeAnimation(s) {
    if (s.locked) {
        // Keep locked ones near the target area
        // if we set home to target, position them there
        s.x = lerp(s.x, s.homeX, 0.12);
        s.y = lerp(s.y, s.homeY, 0.12);
        s.returning = false; s.shakeTimer = 0;
        return;
    }

    if (s.returning) {
        s.x = lerp(s.x, s.homeX, 0.22);
        s.y = lerp(s.y, s.homeY, 0.22);

        if (abs(s.x - s.homeX) < 0.5 && abs(s.y - s.homeY) < 0.5) {
            s.x = s.homeX; s.y = s.homeY; s.returning = false; s.shakeTimer = 0;
        } else if (s.shakeTimer > 0) s.shakeTimer--;
    }

    if (!draggedShape && !s.returning && !s.locked) {
        s.x = lerp(s.x, s.homeX, 0.08);
        s.y = lerp(s.y, s.homeY, 0.08);
    }
}

function drawShape(s) {
    push(); translate(s.x, s.y);
    let shakeX = 0, shakeY = 0;
    if (s.shakeTimer > 0) {
        shakeX = random(-4, 4); shakeY = random(-2, 2);
    }
    translate(shakeX, shakeY);
    noStroke(); fill(s.color);

    if (s.type === "circle") ellipse(0, 0, s.size);
    else if (s.type === "square") { rectMode(CENTER); rect(0, 0, s.size, s.size, 10); }
    else if (s.type === "triangle") triangle(0, -s.size / 2, -s.size / 2, s.size / 2, s.size / 2, s.size / 2);
    else if (s.type === "star") drawStar(0, 0, s.size / 3, s.size / 1.2, 5);
    else if (s.type === "heart") drawHeart(0, 0, s.size);

    pop();
}

function drawStar(x, y, r1, r2, n) {
    let angle = TWO_PI / n, half = angle / 2;
    beginShape();
    for (let a = 0; a < TWO_PI; a += angle) {
        vertex(x + cos(a) * r2, y + sin(a) * r2);
        vertex(x + cos(a + half) * r1, y + sin(a + half) * r1);
    }
    endShape(CLOSE);
}

function drawHeart(x, y, s) {
    beginShape();
    vertex(x, y + s / 4);
    bezierVertex(x - s / 2, y - s / 2, x - s, y + s / 3, x, y + s);
    bezierVertex(x + s, y + s / 3, x + s / 2, y - s / 2, x, y + s / 4);
    endShape(CLOSE);
}

function isMouseOverShape(s) {
    if (s.type === "circle") return dist(mouseX, mouseY, s.x, s.y) < s.size / 2;
    else if (s.type === "square") return mouseX > s.x - s.size / 2 && mouseX < s.x + s.size / 2 &&
        mouseY > s.y - s.size / 2 && mouseY < s.y + s.size / 2;
    else return dist(mouseX, mouseY, s.x, s.y) < s.size / 1.2;
}

function mouseDragged() {
    if (screen === "dragdrop" && draggedShape && !draggedShape.locked) {
        draggedShape.x = mouseX;
        draggedShape.y = mouseY;
        draggedShape.returning = false;
    }
}

function mouseReleased() {
    if (screen === "dragdrop" && draggedShape && !gameFinished) {
        let box = { x: width / 2, y: height - 80, w: 180, h: 100 };
        if (
            mouseX > box.x - box.w / 2 &&
            mouseX < box.x + box.w / 2 &&
            mouseY > box.y - box.h / 2 &&
            mouseY < box.y + box.h / 2
        ) {
            totalAttempts++;
            if (draggedShape.type === targetShape) {
                // Correct
                correctAttempts++;
                feedbackMsg = "âœ… Great job!"; feedbackColor = "green"; feedbackTimer = 120;
                // lock the shape near the target area (spread slightly)
                draggedShape.homeX = box.x + random(-40, 40);
                draggedShape.homeY = box.y + random(-10, 10);
                draggedShape.locked = true;
                draggedShape.returning = false;

                targetsQueue.shift();
                targetShape = targetsQueue.length ? targetsQueue[0] : "";

                if (!targetShape) {
                    // finished â€” use a small delay then show completion UI
                    setTimeout(() => finishDragGame(), 300);
                }
            } else {
                // Wrong
                feedbackMsg = "âŒ Try again!";
                feedbackColor = "red";
                feedbackTimer = 120;
                draggedShape.returning = true;
                draggedShape.shakeTimer = 30;
            }
        } else {
            draggedShape.returning = true;
        }
        draggedShape = null;
    }
}

// Called when the drag game is fully completed
function finishDragGame() {
    gameFinished = true;
    screen = "dragcomplete";
    showCompletionButtons();
}

// ----------------------
// Completion Buttons (use real p5 buttons so clicks always register)
// ----------------------
function showCompletionButtons() {
    hideCompletionButtons(); // ensure no duplicates

    // Return Home button
    completionHomeButton = createButton("ðŸ¡ Return Home");
    completionHomeButton.size(140, 36);
    completionHomeButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFB6C1;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionHomeButton.position(width / 2 - 75 - 70, height - 120 + 10); // align with drawn visuals
    completionHomeButton.mousePressed(() => {
        resetBalloonGame();
        screen = "home";
        for (let k in buttons) buttons[k].show();
        hideCompletionButtons();
    });

    // Play Again button
    completionPlayAgainButton = createButton("ðŸ” Play Again");
    completionPlayAgainButton.size(140, 36);
    completionPlayAgainButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionPlayAgainButton.position(width / 2 + 75 - 70, height - 120 + 10);
    completionPlayAgainButton.mousePressed(() => {
        // Fully restart drag & drop
        startShapeDragGame();
        hideCompletionButtons();
        screen = "dragdrop";
    });
}

function hideCompletionButtons() {
    if (completionHomeButton) {
        completionHomeButton.remove();
        completionHomeButton = null;
    }
    if (completionPlayAgainButton) {
        completionPlayAgainButton.remove();
        completionPlayAgainButton = null;
    }
}

// ----------------------
// ðŸŽ‰ Completion Screen (visual only â€” real buttons handle clicks)
// ----------------------
function drawDragComplete() {
    drawGarden();
    textAlign(CENTER); textFont(fontRegular);
    fill("#2e7d32"); textSize(36);
    text("ðŸŽ‰ Good Job! ðŸŽ‰", width / 2, height / 2 - 40);
    textSize(20); fill("#7a0043");
    text(`You identified ${correctAttempts} shapes with ${totalAttempts} attempts.`, width / 2, height / 2);

}
