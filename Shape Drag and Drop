// ----------------------
// üü£ Shape Drag & Drop
// ----------------------
function shuffleArray(arr) {
    let a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
        let j = floor(random(i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}

function startShapeDragGame() {
    hideCompletionButtons();
    dragShapes = [];
    let startX = 120;
    let spacing = 90;

    for (let i = 0; i < shapeList.length; i++) {
        let s = {
            type: shapeList[i],
            x: startX + i * spacing,
            y: 180,
            homeX: startX + i * spacing,
            homeY: 180,
            size: 70,
            color: color(random(100, 255), random(100, 255), random(100, 255)),
            returning: false,
            shakeTimer: 0,
            locked: false
        };
        dragShapes.push(s);
    }

    targetsQueue = shuffleArray(shapeList);
    targetShape = targetsQueue.length ? targetsQueue[0] : "";
    draggedShape = null;
    feedbackMsg = "";
    feedbackTimer = 0;
    correctAttempts = 0;
    totalAttempts = 0;
    gameFinished = false;

    screen = "dragdrop";
    for (let k in buttons) buttons[k].hide();
    hideCompletionButtons();
}

function drawShapeDragGame() {
    drawGarden();
    textAlign(CENTER);
    textFont(fontRegular);
    fill("#7a0043");
    textSize(32);
    text("üü£ Shape Drag & Drop üü£", width / 2, 60);
    textSize(18);
    fill("#7a0043");
    text(`Correct: ${correctAttempts} / Attempts: ${totalAttempts}`, width - 300, 90);

    for (let s of dragShapes) updateShapeAnimation(s);
    for (let s of dragShapes) drawShape(s);

    fill("#fff6f8"); stroke("#ff8ba0"); strokeWeight(3);
    rectMode(CENTER);
    rect(width / 2, height - 80, 180, 100, 20);
    noStroke(); fill("#7a0043"); textSize(20);
    text((targetShape || "") + " here! --->", width / 4.5, height - 80);

    if (feedbackTimer > 0) {
        fill(feedbackColor);
        textSize(24);
        text(feedbackMsg, width / 2, 120);
        feedbackTimer--;
    }

    drawBackButton();
}

function updateShapeAnimation(s) {
    if (s.locked) {
        s.x = lerp(s.x, s.homeX, 0.12);
        s.y = lerp(s.y, s.homeY, 0.12);
        s.returning = false; s.shakeTimer = 0;
        return;
    }
    if (s.returning) {
        s.x = lerp(s.x, s.homeX, 0.22);
        s.y = lerp(s.y, s.homeY, 0.22);
        if (dist(s.x, s.y, s.homeX, s.homeY) < 1) s.returning = false;
    }
    if (s.shakeTimer > 0) s.shakeTimer--;
}

function drawShape(s) {
    push();
    translate(s.x + (s.shakeTimer > 0 ? random(-5, 5) : 0), s.y);
    fill(s.color); stroke("#7a0043"); strokeWeight(2);
    switch (s.type) {
        case "circle": ellipse(0, 0, s.size); break;
        case "square": rectMode(CENTER); rect(0, 0, s.size, s.size); break;
        case "triangle":
            triangle(-s.size / 2, s.size / 2, 0, -s.size / 2, s.size / 2, s.size / 2);
            break;
        case "star":
            drawStar(0, 0, s.size / 2, s.size / 1.5, 5); break;
        case "heart": drawHeart(0, 0, s.size); break;
    }
    pop();
}

function drawStar(x, y, radius1, radius2, npoints) {
    let angle = TWO_PI / npoints;
    let halfAngle = angle / 2.0;
    beginShape();
    for (let a = 0; a < TWO_PI; a += angle) {
        let sx = x + cos(a) * radius2;
        let sy = y + sin(a) * radius2;
        vertex(sx, sy);
        sx = x + cos(a + halfAngle) * radius1;
        sy = y + sin(a + halfAngle) * radius1;
        vertex(sx, sy);
    }
    endShape(CLOSE);
}

function drawHeart(x, y, size) {
    beginShape();
    vertex(x, y);
    bezierVertex(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);
    bezierVertex(x + size, y + size / 3, x + size / 2, y - size / 2, x, y);
    endShape(CLOSE);
}

function finishDragGame() {
    gameFinished = true;
    screen = "dragcomplete";
    showCompletionButtons();
}

// ----------------------
// Completion Buttons
// ----------------------
// ----------------------
// Completion Buttons (use real p5 buttons so clicks always register)
// ----------------------
function hideCompletionButtons() {
    if (completionHomeButton) {
        completionHomeButton.remove();
        completionHomeButton = null;
    }
    if (completionPlayAgainButton) {
        completionPlayAgainButton.remove();
        completionPlayAgainButton = null;
    }
}

function showCompletionButtons() {
    hideCompletionButtons(); // ensure no duplicates

    let buttonWidth = 140;
    let buttonHeight = 36;
    let spacing = 40;
    let totalWidth = buttonWidth * 2 + spacing;
    let startX = (width - totalWidth) / 2;

    // Return Home button
    completionHomeButton = createButton("üè° Return Home");
    completionHomeButton.size(buttonWidth, buttonHeight);
    completionHomeButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionHomeButton.position(startX, height - 100);
    completionHomeButton.mousePressed(() => {
        resetBalloonGame();
        screen = "home";
        for (let k in buttons) buttons[k].show();
        hideCompletionButtons();
    });

    // Play Again button
    completionPlayAgainButton = createButton("üîÅ Play Again");
    completionPlayAgainButton.size(buttonWidth, buttonHeight);
    completionPlayAgainButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionPlayAgainButton.position(startX + buttonWidth + spacing, height - 100);
    completionPlayAgainButton.mousePressed(() => {
        startShapeDragGame();
        hideCompletionButtons();
        screen = "dragdrop";
    });
}



// ----------------------
// Drag & Drop Mouse Handling
// ----------------------
function mousePressed() {
    if (screen === "balloon" && gameActive) handleBalloonClick();

    if (screen === "dragdrop") {
        for (let i = dragShapes.length - 1; i >= 0; i--) {
            let s = dragShapes[i];
            if (dist(mouseX, mouseY, s.x, s.y) < s.size / 2 && !s.locked) {
                draggedShape = s;
                break;
            }
        }
    }
}

function mouseDragged() {
    if (screen === "dragdrop" && draggedShape && !draggedShape.locked) {
        draggedShape.x = mouseX;
        draggedShape.y = mouseY;
        draggedShape.returning = false;
    } else if (screen === "tracing" && !tracingComplete) {
        drawnPoints.push({ x: mouseX, y: mouseY });
    }
}

function mouseReleased() {
    if (screen === "dragdrop" && draggedShape && !gameFinished) {
        let box = { x: width / 2, y: height - 80, w: 180, h: 100 };
        if (
            mouseX > box.x - box.w / 2 &&
            mouseX < box.x + box.w / 2 &&
            mouseY > box.y - box.h / 2 &&
            mouseY < box.y + box.h / 2
        ) {
            totalAttempts++;
            if (draggedShape.type === targetShape) {
                correctAttempts++;
                feedbackMsg = "‚úÖ Great job!";
                feedbackColor = "green";
                feedbackTimer = 120;
                draggedShape.homeX = box.x + random(-40, 40);
                draggedShape.homeY = box.y + random(-10, 10);
                draggedShape.locked = true;
                draggedShape.returning = false;

                targetsQueue.shift();
                targetShape = targetsQueue.length ? targetsQueue[0] : "";

                if (!targetShape) setTimeout(() => finishDragGame(), 300);
            } else {
                feedbackMsg = "‚ùå Try again!";
                feedbackColor = "red";
                feedbackTimer = 120;
                draggedShape.returning = true;
                draggedShape.shakeTimer = 30;
            }
        } else {
            draggedShape.returning = true;
        }
        draggedShape = null;
    } else if (screen === "tracing" && !tracingComplete) {
        checkTracingAccuracy();
    }
}
