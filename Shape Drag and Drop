// ----------------------
// ðŸŸ£ Shape Drag & Drop
// ----------------------
function shuffleArray(arr) {
    let a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
        let j = floor(random(i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}

function startShapeDragGame() {
    hideCompletionButtons();
    dragShapes = [];
    let startX = 120;
    let spacing = 90;

    for (let i = 0; i < shapeList.length; i++) {
        let s = {
            type: shapeList[i],
            x: startX + i * spacing,
            y: 180,
            homeX: startX + i * spacing,
            homeY: 180,
            size: 70,
            color: color(random(100, 255), random(100, 255), random(100, 255)),
            returning: false,
            shakeTimer: 0,
            locked: false
        };
        dragShapes.push(s);
    }

    targetsQueue = shuffleArray(shapeList);
    targetShape = targetsQueue.length ? targetsQueue[0] : "";
    draggedShape = null;
    feedbackMsg = "";
    feedbackTimer = 0;
    correctAttempts = 0;
    totalAttempts = 0;
    gameFinished = false;

    screen = "dragdrop";
    for (let k in buttons) buttons[k].hide();
    hideCompletionButtons();
}

function drawShapeDragGame() {
    drawGarden();
    textAlign(CENTER);
    textFont(fontRegular);
    fill("#7a0043");
    textSize(32);
    text("ðŸŸ£ Shape Drag & Drop ðŸŸ£", width / 2, 60);
    textSize(18);
    fill("#7a0043");
    text(`Correct: ${correctAttempts} / Attempts: ${totalAttempts}`, width - 300, 90);

    for (let s of dragShapes) updateShapeAnimation(s);
    for (let s of dragShapes) drawShape(s);

    fill("#fff6f8"); stroke("#ff8ba0"); strokeWeight(3);
    rectMode(CENTER);
    rect(width / 2, height - 80, 180, 100, 20);
    noStroke(); fill("#7a0043"); textSize(20);
  
    // Add a shape â†’ emoji map
const shapeEmojis = {
  circle: "ðŸ”µ",
  square: "ðŸŸ¦",
  triangle: "ðŸ”º",
  star: "â­",
  heart: "â¤ï¸"
};

// Pick the matching emoji (or blank if none exists)
let emoji = shapeEmojis[targetShape] || "";

// Updated text line
text((targetShape || "") + " " + emoji + " here! --->", width / 4.5, height - 80);

    if (feedbackTimer > 0) {
        fill(feedbackColor);
        textSize(24);
        text(feedbackMsg, width / 2, 120);
        feedbackTimer--;
    }

    drawBackButton();
}

function updateShapeAnimation(s) {
    if (s.locked) {
        s.x = lerp(s.x, s.homeX, 0.12);
        s.y = lerp(s.y, s.homeY, 0.12);
        s.returning = false; s.shakeTimer = 0;
        return;
    }
    if (s.returning) {
        s.x = lerp(s.x, s.homeX, 0.22);
        s.y = lerp(s.y, s.homeY, 0.22);
        if (dist(s.x, s.y, s.homeX, s.homeY) < 1) s.returning = false;
    }
    if (s.shakeTimer > 0) s.shakeTimer--;
}

function drawShape(s) {
    push();
    translate(s.x + (s.shakeTimer > 0 ? random(-5, 5) : 0), s.y);
    fill(s.color); stroke("#7a0043"); strokeWeight(2);
    switch (s.type) {
        case "circle": ellipse(0, 0, s.size); break;
        case "square": rectMode(CENTER); rect(0, 0, s.size, s.size); break;
        case "triangle":
            triangle(-s.size / 2, s.size / 2, 0, -s.size / 2, s.size / 2, s.size / 2);
            break;
        case "star":
            drawStar(0, 0, s.size / 2, s.size / 1.5, 5); break;
        case "heart": drawHeart(0, 0, s.size); break;
    }
    pop();
}

function drawStar(x, y, radius1, radius2, npoints) {
    let angle = TWO_PI / npoints;
    let halfAngle = angle / 2.0;
    beginShape();
    for (let a = 0; a < TWO_PI; a += angle) {
        let sx = x + cos(a) * radius2;
        let sy = y + sin(a) * radius2;
        vertex(sx, sy);
        sx = x + cos(a + halfAngle) * radius1;
        sy = y + sin(a + halfAngle) * radius1;
        vertex(sx, sy);
    }
    endShape(CLOSE);
}

function drawHeart(x, y, size) {
    beginShape();
    vertex(x, y);
    bezierVertex(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);
    bezierVertex(x + size, y + size / 3, x + size / 2, y - size / 2, x, y);
    endShape(CLOSE);
}

function finishDragGame() {
    gameFinished = true;
    screen = "dragcomplete";
    showCompletionButtons();
}
