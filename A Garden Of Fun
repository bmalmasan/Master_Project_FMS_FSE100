// ----------------------
// Main Variables
// ----------------------
let screen = "home",
    buttons = {},
    fontRegular,
    flowers = [],
    bgOffset = 0;

let balloons = [],
    popParticles = [],
    score = 0,
    gameActive = false;

// üü£ Shape Drag & Drop variables
let dragShapes = [];
let targetShape = "";
let draggedShape = null;
let feedbackMsg = "";
let feedbackColor = "#000";
let feedbackTimer = 0;
let correctAttempts = 0; // number of correct placements
let totalAttempts = 0;   // total attempts (includes wrong tries)
let shapeList = ["circle", "square", "triangle", "star", "heart"];
let gameFinished = false;
let targetsQueue = []; // shuffled order of targets

// Shape Tracing Variables
let tracingPoints = [];
let drawnPoints = [];
let tracingShape = "circle";
let tracingShapes = ["circle", "square", "triangle", "star", "heart"];
let tracingIndex = 0;
let tracingFeedback = "";
let tracingFeedbackTimer = 0;
let tracingComplete = false;
let tracingCorrect = 0; // number of correctly traced shapes
let tracingAttempts = 0; // total attempts for tracing
let tracingHomeButton = null;
let tracingPlayAgainButton = null;

// Completion screen buttons (p5 DOM buttons)
let completionHomeButton = null;
let completionPlayAgainButton = null;


// ----------------------
// Preload
// ----------------------
function preload() {
    fontRegular = 'Comic Sans MS';
}

// ----------------------
// Setup
// ----------------------
function setup() {
    createCanvas(600, 400).mousePressed(handleCanvasClick);

    // Home menu buttons
    let opts = [
        "üéà Balloon Popping Game",
        "üî≤ Shape Tracing Game",
        "üëÜ Shape Drag & Drop",
        "‚ùì How To Play"
    ];
    let screens = ["balloon", "tracing", "dragdrop", "howto"];
    for (let i = 0; i < opts.length; i++) {
        let b = createButton(opts[i]);
        b.size(260, 50);
        b.style("font-size:18px;font-family:Comic Sans MS;background:#FFD1DC;border-radius:20px;border:2px solid #ff8ba0;color:#7a0043;");
        b.position(width / 2 - 130, 150 + 60 * i);
        b.mousePressed(() => changeScreen(screens[i]));
        buttons[screens[i]] = b;
    }

    // Animated flowers
    for (let i = 0; i < 10; i++) {
        flowers.push({
            x: random(width),
            y: random(height - 60, height - 20),
            a: random(TWO_PI),
            c: color(random(255), random(255), random(255)),
            t: color(random(255), random(255), random(255))
        });
    }
}

// ----------------------
// Draw Loop
// ----------------------
function draw() {
    drawGarden();

    switch (screen) {
        case "home": drawHome(); break;
        case "balloon": drawBalloonGame(); break;
        case "dragdrop": drawShapeDragGame(); break;
        case "howto": drawHowTo(); break;
        case "gameover": drawGameOver(); break;
        case "dragcomplete": drawDragComplete(); break;
        case "tracing": drawShapeTracingGame(); break;
        case "tracingcomplete": drawTracingComplete(); break;

    }
}

// ----------------------
// üå∏ Garden Background
// ----------------------
function drawGarden() {
    bgOffset += 0.0002;
    let top = lerpColor(color("#aee6ff"), color("#b0dfff"), sin(bgOffset) * 0.5 + 0.5);
    let bottom = lerpColor(color("#e0ffe7"), color("#d6ffe0"), sin(bgOffset) * 0.5 + 0.5);

    for (let y = 0; y < height; y++) {
        stroke(lerpColor(top, bottom, y / height));
        line(0, y, width, y);
    }

    noStroke();
    fill(255, 255, 120); ellipse(80, 80, 100); // Sun
    fill(100, 200, 100); rect(0, height - 80, width, 80); // Ground
    fill(90, 180, 90);
    ellipse(150, height - 40, 300, 100);
    ellipse(450, height - 40, 400, 120);

    for (let f of flowers) {
        f.a += 0.1;
        drawFlower(f.x + sin(f.a) * 2, f.y, f);
    }
}

function drawFlower(x, y, f) {
    f.c = lerpColor(f.c, f.t, 0.005);
    if (abs(red(f.c) - red(f.t)) + abs(green(f.c) - green(f.t)) + abs(blue(f.c) - blue(f.t)) < 3) {
        f.t = color(random(255), random(255), random(255));
    }

    noStroke();
    fill("green"); rect(x - 1, y, 2, 20); // stem
    fill(f.c);
    for (let a = 0; a < TWO_PI; a += PI / 3) {
        ellipse(x + cos(a) * 8, y - 10 + sin(a) * 8, 10);
    }
    fill("#FFD700"); circle(x, y - 10, 8);
}

// ----------------------
// üè† Menu & Buttons
// ----------------------
function drawHome() {
    textAlign(CENTER);
    textSize(38);
    fill("#ff66a3");
    textFont(fontRegular);
    text("üåº A Garden of Fun üåº", width / 2, 100);
}

function drawBackButton() {
    fill("#FFB6C1"); stroke("#ff8ba0");
    rectMode(CENTER); rect(width / 2, height - 40, 180, 40, 15);
    noStroke(); fill("#7a0043");
    textSize(18); text("üè° Return to Home", width / 2, height - 40);
}

function drawNextButton() {
    fill("#FFD1DC"); stroke("#ff8ba0");
    rectMode(CENTER); rect(width / 2, height - 90, 180, 40, 15);
    noStroke(); fill("#7a0043");
    textSize(18); text("‚û°Ô∏è Next", width / 2, height - 90);
}

function drawPlaceholder(txt, col) {
    textAlign(CENTER);
    textSize(32);
    fill(col);
    textFont(fontRegular);
    text(txt, width / 2, height / 2);
    drawBackButton();
    drawNextButton();
}

function changeScreen(s) {
    // Hide any completion buttons when changing screens
    hideCompletionButtons();

    screen = s;
    for (let k in buttons) buttons[k].hide();

    if (s === "balloon") {
        resetBalloonGame();
        setTimeout(() => (gameActive = true), 500);
    }
    if (s === "dragdrop") startShapeDragGame();
    if (s === "tracing") startShapeTracingGame();

}

// ----------------------
// üåº Handle Clicks
// ----------------------
function handleCanvasClick() {
    // Generic Return to Home from many screens (rect-based)
    if (screen === "balloon" || (screen !== "home" && screen !== "gameover" && screen !== "dragcomplete" && screen !== "blank")) {
        if (mouseX > width / 2 - 90 && mouseX < width / 2 + 90 && mouseY > height - 60 && mouseY < height - 20) {
            resetBalloonGame();
            screen = "home";
            for (let k in buttons) buttons[k].show();
            hideCompletionButtons();
            return;
        }
    }

    // Special case: in gameover screen return to home
    if (screen === "gameover") {
        if (mouseX > width / 2 - 90 && mouseX < width / 2 + 90 && mouseY > height - 60 && mouseY < height - 20) {
            resetBalloonGame();
            screen = "home";
            for (let k in buttons) buttons[k].show();
            hideCompletionButtons();
            return;
        }
    }

    // If we are on dragcomplete, p5 DOM buttons handle actions; do nothing here.
}

// ----------------------
// üéà Balloon Game
// ----------------------
function drawBalloonGame() {
    drawGarden();

    // Spawn balloons
    if (frameCount % 60 === 0 && balloons.length < 10) {
        balloons.push({
            x: random(50, width - 50),
            y: height + 50,
            s: random(50, 90),
            c: color(random(150, 255), random(100, 255), random(150, 255)),
            sp: random(1.2, 2.5),
            w: random(TWO_PI)
        });
    }

    // Update balloons
    for (let i = balloons.length - 1; i >= 0; i--) {
        let b = balloons[i];
        b.y -= b.sp;
        b.x += sin(frameCount * 0.05 + b.w) * 1.5;
        stroke(150); line(b.x, b.y, b.x, b.y + 40);
        noStroke(); fill(b.c);
        ellipse(b.x, b.y, b.s * 0.9, b.s);
        if (b.y < -50) balloons.splice(i, 1);
    }

    // Pop particles
    for (let i = popParticles.length - 1; i >= 0; i--) {
        let p = popParticles[i];
        p.x += p.vx; p.y += p.vy; p.life -= 3;
        fill(p.c.levels[0], p.c.levels[1], p.c.levels[2], p.life);
        noStroke(); ellipse(p.x, p.y, 6);
        if (p.life <= 0) popParticles.splice(i, 1);
    }

    // HUD
    noStroke();
    fill("#7a0043");
    textAlign(CENTER); textSize(32); text("üéà Balloon Popping Game üéà", width / 2, 40);
    textSize(20); text(`Score: ${score}`, width - 50, 30);

    drawBackButton();
}

function handleBalloonClick() {
    let clickedBalloon = false;

    for (let i = balloons.length - 1; i >= 0; i--) {
        let b = balloons[i];
        if (dist(mouseX, mouseY, b.x, b.y) < b.s / 2) {
            clickedBalloon = true;
            for (let j = 0; j < 15; j++) {
                popParticles.push({
                    x: b.x,
                    y: b.y,
                    vx: random(-2, 2),
                    vy: random(-2, 2),
                    life: 255,
                    c: b.c
                });
            }
            balloons.splice(i, 1);
            score++;
            break;
        }
    }

    if (!clickedBalloon) {
        gameActive = false;
        screen = "gameover";
    }
}

function mousePressed() {
    // Start dragging (only for dragdrop)
    if (screen === "dragdrop") {
        for (let s of dragShapes) {
            if (isMouseOverShape(s) && !s.returning && !s.locked) {
                draggedShape = s;
                // bring to front (move last in array)
                let idx = dragShapes.indexOf(s);
                if (idx >= 0) {
                    dragShapes.splice(idx, 1);
                    dragShapes.push(s);
                }
                break;
            }
        }
    }

    if (screen === "balloon" && gameActive) handleBalloonClick();

    // Note: we call handleCanvasClick as well (for generic back/home)
    handleCanvasClick();
}

function drawGameOver() {
    drawGarden();
    textAlign(CENTER);
    textSize(40); fill("#ff4d6d"); textFont(fontRegular);
    text("üí• Game Over üí•", width / 2, height / 2 - 40);
    textSize(22); fill("#7a0043");
    text(`Your Score: ${score}`, width / 2, height / 2 + 10);
    drawBackButton();
}

function resetBalloonGame() {
    score = 0; balloons = []; popParticles = []; gameActive = false;
}

// ‚ùì How To
function drawHowTo() {
    textAlign(CENTER);
    textSize(26); fill("#7a0043"); textFont(fontRegular);
    text("‚ùì How to Play ‚ùì", width / 2, 100);
    textSize(18);
    text(
        "üéà Pop balloons by clicking!\nüö´ Clicking background ends the game.\nüü£ Drag and drop the right shape!\n\nüè° Press 'Return to Home' to go back.",
        width / 2, height / 2
    );
    drawBackButton();
}

// ----------------------
// üü£ Shape Drag & Drop
// ----------------------
function shuffleArray(arr) {
    let a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
        let j = floor(random(i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}

function startShapeDragGame() {
    hideCompletionButtons();
    dragShapes = [];
    let startX = 120;
    let spacing = 90;

    for (let i = 0; i < shapeList.length; i++) {
        let s = {
            type: shapeList[i],
            x: startX + i * spacing,
            y: 180,
            homeX: startX + i * spacing,
            homeY: 180,
            size: 70,
            color: color(random(100, 255), random(100, 255), random(100, 255)),
            returning: false,
            shakeTimer: 0,
            locked: false
        };
        dragShapes.push(s);
    }

    targetsQueue = shuffleArray(shapeList);
    targetShape = targetsQueue.length ? targetsQueue[0] : "";
    draggedShape = null;
    feedbackMsg = "";
    feedbackTimer = 0;
    correctAttempts = 0;
    totalAttempts = 0;
    gameFinished = false;

    screen = "dragdrop";
    for (let k in buttons) buttons[k].hide();
    hideCompletionButtons();
}

function drawShapeDragGame() {
    drawGarden();
    textAlign(CENTER);
    textFont(fontRegular);
    fill("#7a0043");
    textSize(32);
    text("üü£ Shape Drag & Drop üü£", width / 2, 60);
    textSize(18);
    fill("#7a0043");
    text(`Correct: ${correctAttempts} / Attempts: ${totalAttempts}`, width - 300, 90);

    for (let s of dragShapes) updateShapeAnimation(s);
    for (let s of dragShapes) drawShape(s);

    fill("#fff6f8"); stroke("#ff8ba0"); strokeWeight(3);
    rectMode(CENTER);
    rect(width / 2, height - 80, 180, 100, 20);
    noStroke(); fill("#7a0043"); textSize(20);
  
    // Add a shape ‚Üí emoji map
const shapeEmojis = {
  circle: "üîµ",
  square: "üü¶",
  triangle: "üî∫",
  star: "‚≠ê",
  heart: "‚ù§Ô∏è"
};

// Pick the matching emoji (or blank if none exists)
let emoji = shapeEmojis[targetShape] || "";

// Updated text line
text((targetShape || "") + " " + emoji + " here! --->", width / 4.5, height - 80);

    if (feedbackTimer > 0) {
        fill(feedbackColor);
        textSize(24);
        text(feedbackMsg, width / 2, 120);
        feedbackTimer--;
    }

    drawBackButton();
}

function updateShapeAnimation(s) {
    if (s.locked) {
        s.x = lerp(s.x, s.homeX, 0.12);
        s.y = lerp(s.y, s.homeY, 0.12);
        s.returning = false; s.shakeTimer = 0;
        return;
    }
    if (s.returning) {
        s.x = lerp(s.x, s.homeX, 0.22);
        s.y = lerp(s.y, s.homeY, 0.22);
        if (dist(s.x, s.y, s.homeX, s.homeY) < 1) s.returning = false;
    }
    if (s.shakeTimer > 0) s.shakeTimer--;
}

function drawShape(s) {
    push();
    translate(s.x + (s.shakeTimer > 0 ? random(-5, 5) : 0), s.y);
    fill(s.color); stroke("#7a0043"); strokeWeight(2);
    switch (s.type) {
        case "circle": ellipse(0, 0, s.size); break;
        case "square": rectMode(CENTER); rect(0, 0, s.size, s.size); break;
        case "triangle":
            triangle(-s.size / 2, s.size / 2, 0, -s.size / 2, s.size / 2, s.size / 2);
            break;
        case "star":
            drawStar(0, 0, s.size / 2, s.size / 1.5, 5); break;
        case "heart": drawHeart(0, 0, s.size); break;
    }
    pop();
}

function drawStar(x, y, radius1, radius2, npoints) {
    let angle = TWO_PI / npoints;
    let halfAngle = angle / 2.0;
    beginShape();
    for (let a = 0; a < TWO_PI; a += angle) {
        let sx = x + cos(a) * radius2;
        let sy = y + sin(a) * radius2;
        vertex(sx, sy);
        sx = x + cos(a + halfAngle) * radius1;
        sy = y + sin(a + halfAngle) * radius1;
        vertex(sx, sy);
    }
    endShape(CLOSE);
}

function drawHeart(x, y, size) {
    beginShape();
    vertex(x, y);
    bezierVertex(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);
    bezierVertex(x + size, y + size / 3, x + size / 2, y - size / 2, x, y);
    endShape(CLOSE);
}

function finishDragGame() {
    gameFinished = true;
    screen = "dragcomplete";
    showCompletionButtons();
}

// ----------------------
// Completion Buttons
// ----------------------
// ----------------------
// Completion Buttons (use real p5 buttons so clicks always register)
// ----------------------
function hideCompletionButtons() {
    if (completionHomeButton) {
        completionHomeButton.remove();
        completionHomeButton = null;
    }
    if (completionPlayAgainButton) {
        completionPlayAgainButton.remove();
        completionPlayAgainButton = null;
    }
}

function showCompletionButtons() {
    hideCompletionButtons(); // ensure no duplicates

    let buttonWidth = 140;
    let buttonHeight = 36;
    let spacing = 40;
    let totalWidth = buttonWidth * 2 + spacing;
    let startX = (width - totalWidth) / 2;

    // Return Home button
    completionHomeButton = createButton("üè° Return Home");
    completionHomeButton.size(buttonWidth, buttonHeight);
    completionHomeButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionHomeButton.position(startX, height - 100);
    completionHomeButton.mousePressed(() => {
        resetBalloonGame();
        screen = "home";
        for (let k in buttons) buttons[k].show();
        hideCompletionButtons();
    });

    // Play Again button
    completionPlayAgainButton = createButton("üîÅ Play Again");
    completionPlayAgainButton.size(buttonWidth, buttonHeight);
    completionPlayAgainButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionPlayAgainButton.position(startX + buttonWidth + spacing, height - 100);
    completionPlayAgainButton.mousePressed(() => {
        startShapeDragGame();
        hideCompletionButtons();
        screen = "dragdrop";
    });
}



// ----------------------
// Drag & Drop Mouse Handling
// ----------------------
function mousePressed() {
    if (screen === "balloon" && gameActive) handleBalloonClick();

    if (screen === "dragdrop") {
        for (let i = dragShapes.length - 1; i >= 0; i--) {
            let s = dragShapes[i];
            if (dist(mouseX, mouseY, s.x, s.y) < s.size / 2 && !s.locked) {
                draggedShape = s;
                break;
            }
        }
    }
}

function mouseDragged() {
    if (screen === "dragdrop" && draggedShape && !draggedShape.locked) {
        draggedShape.x = mouseX;
        draggedShape.y = mouseY;
        draggedShape.returning = false;
    } else if (screen === "tracing" && !tracingComplete) {
        drawnPoints.push({ x: mouseX, y: mouseY });
    }
}

function mouseReleased() {
    if (screen === "dragdrop" && draggedShape && !gameFinished) {
        let box = { x: width / 2, y: height - 80, w: 180, h: 100 };
        if (
            mouseX > box.x - box.w / 2 &&
            mouseX < box.x + box.w / 2 &&
            mouseY > box.y - box.h / 2 &&
            mouseY < box.y + box.h / 2
        ) {
            totalAttempts++;
            if (draggedShape.type === targetShape) {
                correctAttempts++;
                feedbackMsg = "‚úÖ Great job!";
                feedbackColor = "green";
                feedbackTimer = 120;
                draggedShape.homeX = box.x + random(-40, 40);
                draggedShape.homeY = box.y + random(-10, 10);
                draggedShape.locked = true;
                draggedShape.returning = false;

                targetsQueue.shift();
                targetShape = targetsQueue.length ? targetsQueue[0] : "";

                if (!targetShape) setTimeout(() => finishDragGame(), 300);
            } else {
                feedbackMsg = "‚ùå Try again!";
                feedbackColor = "red";
                feedbackTimer = 120;
                draggedShape.returning = true;
                draggedShape.shakeTimer = 30;
            }
        } else {
            draggedShape.returning = true;
        }
        draggedShape = null;
    } else if (screen === "tracing" && !tracingComplete) {
        checkTracingAccuracy();
    }
}

// ----------------------
// Completion Buttons (use real p5 buttons so clicks always register)
// ----------------------
function showCompletionButtons() {
    hideCompletionButtons(); // ensure no duplicates

    // Return Home button
    completionHomeButton = createButton("üè° Return Home");
    completionHomeButton.size(140, 36);
    completionHomeButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFB6C1;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionHomeButton.position(width / 2 - 75 - 70, height - 120 + 10); // align with drawn visuals
    completionHomeButton.mousePressed(() => {
        resetBalloonGame();
        screen = "home";
        for (let k in buttons) buttons[k].show();
        hideCompletionButtons();
    });

    // Play Again button
    completionPlayAgainButton = createButton("üîÅ Play Again");
    completionPlayAgainButton.size(140, 36);
    completionPlayAgainButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionPlayAgainButton.position(width / 2 + 75 - 70, height - 120 + 10);
    completionPlayAgainButton.mousePressed(() => {
        // Fully restart drag & drop
        startShapeDragGame();
        hideCompletionButtons();
        screen = "dragdrop";
    });
}

function hideCompletionButtons() {
    if (completionHomeButton) {
        completionHomeButton.remove();
        completionHomeButton = null;
    }
    if (completionPlayAgainButton) {
        completionPlayAgainButton.remove();
        completionPlayAgainButton = null;
    }
}

// ----------------------
// üéâ Completion Screen (visual only ‚Äî real buttons handle clicks)
// ----------------------
function drawDragComplete() {
    drawGarden();
    textAlign(CENTER); textFont(fontRegular);
    fill("#2e7d32"); textSize(36);
    text("üéâ Good Job! üéâ", width / 2, height / 2 - 40);
    textSize(20); fill("#7a0043");
    text(`You identified ${correctAttempts} shapes with ${totalAttempts} attempts.`, width / 2, height / 2);

}


// ----------------------
// Start the Shape Tracing Game
// ----------------------
function startShapeTracingGame() {
  hideTracingCompletionButtons();
  tracingIndex = 0;
  tracingShape = tracingShapes[tracingIndex];
  drawnPoints = [];
  tracingFeedback = "";
  tracingFeedbackTimer = 0;
  tracingComplete = false;
  tracingCorrect = 0;
  tracingAttempts = 0;
  generateTracingPoints(tracingShape);
  screen = "tracing";
  for (let k in buttons) buttons[k].hide();
}

// ----------------------
// Generate Points for Tracing Shapes
// ----------------------
function generateTracingPoints(shape) {
  tracingPoints = [];
  let cx = width / 2, cy = height / 2 + 20, size = 120;

  if (shape === "circle") {
    for (let a = 0; a < TWO_PI; a += 0.1) {
      tracingPoints.push({ x: cx + cos(a) * size / 2, y: cy + sin(a) * size / 2 });
    }
  } else if (shape === "square") {
    let s = size / 2;
    tracingPoints = [
      { x: cx - s, y: cy - s },
      { x: cx + s, y: cy - s },
      { x: cx + s, y: cy + s },
      { x: cx - s, y: cy + s }
    ];
  } else if (shape === "triangle") {
    let s = size / 2;
    tracingPoints = [
      { x: cx, y: cy - s },
      { x: cx - s, y: cy + s },
      { x: cx + s, y: cy + s }
    ];
  } else if (shape === "star") {
    for (let a = 0; a < TWO_PI; a += TWO_PI / 5) {
      tracingPoints.push({ x: cx + cos(a) * size / 2, y: cy + sin(a) * size / 2 });
      tracingPoints.push({ x: cx + cos(a + PI / 5) * size / 4, y: cy + sin(a + PI / 5) * size / 4 });
    }
  } else if (shape === "heart") {
    for (let a = 0; a < PI; a += 0.05) {
      let x = 16 * pow(sin(a), 3);
      let y = 13 * cos(a) - 5 * cos(2 * a) - 2 * cos(3 * a) - cos(4 * a);
      tracingPoints.push({ x: cx + x * 5, y: cy - y * 5 });
    }
  }
}

// ----------------------
// Draw the Shape Tracing Game
// ----------------------
const tracingEmojis = {
  circle: "üü†",
  square: "üü¶",
  triangle: "üî∫",
  star: "‚≠ê",
  heart: "ü©∑"
};

// Ask child which shape to draw
  let emoji = tracingEmojis[tracingShape] || "";
  textSize(28);
  fill("#7a0043");
  text("Draw the " + tracingShape + " " + emoji + "!", width / 2, 90);


function drawShapeTracingGame() {
  drawGarden();
  textAlign(CENTER);
  textFont(fontRegular);
  fill("#7a0043");
  textSize(32);
  text("Shape Tracing Game", width / 2, 50);

  // ‚≠ê NEW: Instruction with shape + emoji
  let emoji = tracingEmojis[tracingShape] || "";
  textSize(28);
  text("Draw the " + tracingShape + " " + emoji + "!", width / 2, 90);

  // Draw target shape outline
  stroke(200);
  noFill();
  strokeWeight(2);
  beginShape();
  for (let p of tracingPoints) vertex(p.x, p.y);
  endShape(CLOSE);

  // Draw user strokes
  noFill();
  stroke("#7a0043");
  strokeWeight(3);
  beginShape();
  for (let p of drawnPoints) vertex(p.x, p.y);
  endShape();

  // Feedback message
    if (tracingFeedbackTimer > 0) {
    fill(tracingFeedback === "‚úÖ Great tracing!" ? "green" : "red");
    noStroke();
    textSize(24);
    text(tracingFeedback, width / 2, 150);
    tracingFeedbackTimer--;
  }

  drawBackButton();
}
// ----------------------
// Check Accuracy of Tracing
// ----------------------

function checkTracingAccuracy() {
  tracingAttempts++;

  if (drawnPoints.length < 10) {
    tracingFeedback = "‚ùå Too short! Try again.";
    tracingFeedbackTimer = 120;
    drawnPoints = [];
    return;
  }

  // Compare distance from traced path to shape outline
  let totalDist = 0;
  for (let p of drawnPoints) {
    let minD = Infinity;
    for (let t of tracingPoints) {
      let d = dist(p.x, p.y, t.x, t.y);
      if (d < minD) minD = d;
    }
    totalDist += minD;
  }
  let avgDist = totalDist / drawnPoints.length;

  if (avgDist < 25) {
    tracingFeedback = "‚úÖ Great tracing!";
    tracingFeedbackTimer = 100;
    tracingCorrect++;
    tracingIndex++;

    if (tracingIndex >= tracingShapes.length) {
      setTimeout(() => finishTracingGame(), 300);
    } else {
      tracingShape = tracingShapes[tracingIndex];
      generateTracingPoints(tracingShape);
    }
  } else {
    tracingFeedback = "‚ùå Try to follow the outline!";
    tracingFeedbackTimer = 100;
  }

  drawnPoints = [];
}


// ----------------------
// Finish the Tracing Game
// ----------------------
function finishTracingGame() {
  screen = "tracingcomplete";
  showTracingCompletionButtons();
}

// ----------------------
// Completion Buttons
// ----------------------
function showTracingCompletionButtons() {
  hideTracingCompletionButtons();

  let buttonWidth = 140;
  let buttonHeight = 36;
  let spacing = 20;

  tracingHomeButton = createButton("üè° Return Home");
  tracingHomeButton.size(buttonWidth, buttonHeight);
  tracingHomeButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
  tracingHomeButton.position(width / 2 - buttonWidth - spacing, height - 120);
  tracingHomeButton.mousePressed(() => {
    resetTracingGame();
    screen = "home";
    for (let k in buttons) buttons[k].show();
    hideTracingCompletionButtons();
  });

  tracingPlayAgainButton = createButton("üîÅ Play Again");
  tracingPlayAgainButton.size(buttonWidth, buttonHeight);
  tracingPlayAgainButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
  tracingPlayAgainButton.position(width / 2 + spacing, height - 120);
  tracingPlayAgainButton.mousePressed(() => {
    startShapeTracingGame();
    hideTracingCompletionButtons();
    screen = "tracing";
  });
}

function hideTracingCompletionButtons() {
  if (tracingHomeButton) { tracingHomeButton.remove(); tracingHomeButton = null; }
  if (tracingPlayAgainButton) { tracingPlayAgainButton.remove(); tracingPlayAgainButton = null; }
}

// ----------------------
// Reset Tracing Game
// ----------------------
function resetTracingGame() {
  tracingIndex = 0;
  tracingShape = tracingShapes[tracingIndex];
  drawnPoints = [];
  tracingFeedback = "";
  tracingFeedbackTimer = 0;
  tracingCorrect = 0;
  tracingAttempts = 0;
  generateTracingPoints(tracingShape);
}

// ----------------------
// Draw Completion Screen
// ----------------------
function drawTracingComplete() {
  drawGarden();
  textAlign(CENTER);
  textFont(fontRegular);
  fill("#2e7d32");
  textSize(36);
  text("üéâ Great Job! üéâ", width / 2, height / 2 - 40);
  textSize(20);
  fill("#7a0043");
  text(`You traced ${tracingCorrect} shapes out of ${tracingAttempts} attempts.`, width / 2, height / 2);
}
// ----------------------
// End of sketch
// ----------------------
