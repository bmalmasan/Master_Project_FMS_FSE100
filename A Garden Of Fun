// ----------------------
// Main Variables
// ----------------------
let screen = "home",
    buttons = {},
    fontRegular,
    flowers = [],
    bgOffset = 0;

let balloons = [],
    popParticles = [],
    score = 0,
    gameActive = false;

// üü£ Shape Drag & Drop variables
let dragShapes = [];
let targetShape = "";
let draggedShape = null;
let feedbackMsg = "";
let feedbackColor = "#000";
let feedbackTimer = 0;
let correctAttempts = 0; // number of correct placements
let totalAttempts = 0;   // total attempts (includes wrong tries)
let shapeList = ["circle", "square", "triangle", "star", "heart"];
let gameFinished = false;
let targetsQueue = []; // shuffled order of targets

// Completion screen buttons (p5 DOM buttons)
let completionHomeButton = null;
let completionPlayAgainButton = null;

// ----------------------
// Preload
// ----------------------
function preload() {
    fontRegular = 'Comic Sans MS';
}

// ----------------------
// Setup
// ----------------------
function setup() {
    createCanvas(600, 400).mousePressed(handleCanvasClick);

    // Home menu buttons
    let opts = [
        "üéà Balloon Popping Game",
        "üî∫ Shape Tracing Game",
        "üü£ Shape Drag & Drop",
        "‚ùì How To Play"
    ];
    let screens = ["balloon", "tracing", "dragdrop", "howto"];
    for (let i = 0; i < opts.length; i++) {
        let b = createButton(opts[i]);
        b.size(260, 50);
        b.style("font-size:18px;font-family:Comic Sans MS;background:#FFD1DC;border-radius:20px;border:2px solid #ff8ba0;color:#7a0043;");
        b.position(width / 2 - 130, 150 + 60 * i);
        b.mousePressed(() => changeScreen(screens[i]));
        buttons[screens[i]] = b;
    }

    // Animated flowers
    for (let i = 0; i < 10; i++) {
        flowers.push({
            x: random(width),
            y: random(height - 60, height - 20),
            a: random(TWO_PI),
            c: color(random(255), random(255), random(255)),
            t: color(random(255), random(255), random(255))
        });
    }
}

// ----------------------
// Draw Loop
// ----------------------
function draw() {
    drawGarden();

    switch (screen) {
        case "home": drawHome(); break;
        case "balloon": drawBalloonGame(); break;
        case "tracing": drawPlaceholder("üî∫ Shape Tracing Game üî∫", "#006d77"); break;
        case "dragdrop": drawShapeDragGame(); break;
        case "howto": drawHowTo(); break;
        case "gameover": drawGameOver(); break;
        case "dragcomplete": drawDragComplete(); break;
        case "blank": drawPlaceholder("üå∏ Blank Game Page üå∏", "#333"); break;
    }
}

// ----------------------
// üå∏ Garden Background
// ----------------------
function drawGarden() {
    bgOffset += 0.0002;
    let top = lerpColor(color("#aee6ff"), color("#b0dfff"), sin(bgOffset) * 0.5 + 0.5);
    let bottom = lerpColor(color("#e0ffe7"), color("#d6ffe0"), sin(bgOffset) * 0.5 + 0.5);

    for (let y = 0; y < height; y++) {
        stroke(lerpColor(top, bottom, y / height));
        line(0, y, width, y);
    }

    noStroke();
    fill(255, 255, 120); ellipse(80, 80, 100); // Sun
    fill(100, 200, 100); rect(0, height - 80, width, 80); // Ground
    fill(90, 180, 90);
    ellipse(150, height - 40, 300, 100);
    ellipse(450, height - 40, 400, 120);

    for (let f of flowers) {
        f.a += 0.1;
        drawFlower(f.x + sin(f.a) * 2, f.y, f);
    }
}

function drawFlower(x, y, f) {
    f.c = lerpColor(f.c, f.t, 0.005);
    if (abs(red(f.c) - red(f.t)) + abs(green(f.c) - green(f.t)) + abs(blue(f.c) - blue(f.t)) < 3) {
        f.t = color(random(255), random(255), random(255));
    }

    noStroke();
    fill("green"); rect(x - 1, y, 2, 20); // stem
    fill(f.c);
    for (let a = 0; a < TWO_PI; a += PI / 3) {
        ellipse(x + cos(a) * 8, y - 10 + sin(a) * 8, 10);
    }
    fill("#FFD700"); circle(x, y - 10, 8);
}

// ----------------------
// üè† Menu & Buttons
// ----------------------
function drawHome() {
    textAlign(CENTER);
    textSize(38);
    fill("#ff66a3");
    textFont(fontRegular);
    text("üåº A Garden of Fun üåº", width / 2, 100);
}

function drawBackButton() {
    fill("#FFB6C1"); stroke("#ff8ba0");
    rectMode(CENTER); rect(width / 2, height - 40, 180, 40, 15);
    noStroke(); fill("#7a0043");
    textSize(18); text("üè° Return to Home", width / 2, height - 40);
}

function drawNextButton() {
    fill("#FFD1DC"); stroke("#ff8ba0");
    rectMode(CENTER); rect(width / 2, height - 90, 180, 40, 15);
    noStroke(); fill("#7a0043");
    textSize(18); text("‚û°Ô∏è Next", width / 2, height - 90);
}

function drawPlaceholder(txt, col) {
    textAlign(CENTER);
    textSize(32);
    fill(col);
    textFont(fontRegular);
    text(txt, width / 2, height / 2);
    drawBackButton();
    drawNextButton();
}

function changeScreen(s) {
    // Hide any completion buttons when changing screens
    hideCompletionButtons();

    screen = s;
    for (let k in buttons) buttons[k].hide();

    if (s === "balloon") {
        resetBalloonGame();
        setTimeout(() => (gameActive = true), 500);
    }
    if (s === "dragdrop") startShapeDragGame();
}

// ----------------------
// üåº Handle Clicks
// ----------------------
function handleCanvasClick() {
    // Generic Return to Home from many screens (rect-based)
    if (screen === "balloon" || (screen !== "home" && screen !== "gameover" && screen !== "dragcomplete" && screen !== "blank")) {
        if (mouseX > width / 2 - 90 && mouseX < width / 2 + 90 && mouseY > height - 60 && mouseY < height - 20) {
            resetBalloonGame();
            screen = "home";
            for (let k in buttons) buttons[k].show();
            hideCompletionButtons();
            return;
        }
    }

    // Special case: in gameover screen return to home
    if (screen === "gameover") {
        if (mouseX > width / 2 - 90 && mouseX < width / 2 + 90 && mouseY > height - 60 && mouseY < height - 20) {
            resetBalloonGame();
            screen = "home";
            for (let k in buttons) buttons[k].show();
            hideCompletionButtons();
            return;
        }
    }

    // If we are on dragcomplete, p5 DOM buttons handle actions; do nothing here.
}

// ----------------------
// üéà Balloon Game
// ----------------------
function drawBalloonGame() {
    drawGarden();

    // Spawn balloons
    if (frameCount % 60 === 0 && balloons.length < 10) {
        balloons.push({
            x: random(50, width - 50),
            y: height + 50,
            s: random(50, 90),
            c: color(random(150, 255), random(100, 255), random(150, 255)),
            sp: random(1.2, 2.5),
            w: random(TWO_PI)
        });
    }

    // Update balloons
    for (let i = balloons.length - 1; i >= 0; i--) {
        let b = balloons[i];
        b.y -= b.sp;
        b.x += sin(frameCount * 0.05 + b.w) * 1.5;
        stroke(150); line(b.x, b.y, b.x, b.y + 40);
        noStroke(); fill(b.c);
        ellipse(b.x, b.y, b.s * 0.9, b.s);
        if (b.y < -50) balloons.splice(i, 1);
    }

    // Pop particles
    for (let i = popParticles.length - 1; i >= 0; i--) {
        let p = popParticles[i];
        p.x += p.vx; p.y += p.vy; p.life -= 3;
        fill(p.c.levels[0], p.c.levels[1], p.c.levels[2], p.life);
        noStroke(); ellipse(p.x, p.y, 6);
        if (p.life <= 0) popParticles.splice(i, 1);
    }

    // HUD
    noStroke();
    fill("#7a0043");
    textAlign(CENTER); textSize(32); text("üéà Balloon Popping Game üéà", width / 2, 40);
    textSize(20); text(`Score: ${score}`, width - 50, 30);

    drawBackButton();
}

function handleBalloonClick() {
    let clickedBalloon = false;

    for (let i = balloons.length - 1; i >= 0; i--) {
        let b = balloons[i];
        if (dist(mouseX, mouseY, b.x, b.y) < b.s / 2) {
            clickedBalloon = true;
            for (let j = 0; j < 15; j++) {
                popParticles.push({
                    x: b.x,
                    y: b.y,
                    vx: random(-2, 2),
                    vy: random(-2, 2),
                    life: 255,
                    c: b.c
                });
            }
            balloons.splice(i, 1);
            score++;
            break;
        }
    }

    if (!clickedBalloon) {
        gameActive = false;
        screen = "gameover";
    }
}

function mousePressed() {
    // Start dragging (only for dragdrop)
    if (screen === "dragdrop") {
        for (let s of dragShapes) {
            if (isMouseOverShape(s) && !s.returning && !s.locked) {
                draggedShape = s;
                // bring to front (move last in array)
                let idx = dragShapes.indexOf(s);
                if (idx >= 0) {
                    dragShapes.splice(idx, 1);
                    dragShapes.push(s);
                }
                break;
            }
        }
    }

    if (screen === "balloon" && gameActive) handleBalloonClick();

    // Note: we call handleCanvasClick as well (for generic back/home)
    handleCanvasClick();
}

function drawGameOver() {
    drawGarden();
    textAlign(CENTER);
    textSize(40); fill("#ff4d6d"); textFont(fontRegular);
    text("üí• Game Over üí•", width / 2, height / 2 - 40);
    textSize(22); fill("#7a0043");
    text(`Your Score: ${score}`, width / 2, height / 2 + 10);
    drawBackButton();
}

function resetBalloonGame() {
    score = 0; balloons = []; popParticles = []; gameActive = false;
}

// ‚ùì How To
function drawHowTo() {
    textAlign(CENTER);
    textSize(26); fill("#7a0043"); textFont(fontRegular);
    text("‚ùì How to Play ‚ùì", width / 2, 100);
    textSize(18);
    text(
        "üéà Pop balloons by clicking!\nüö´ Clicking background ends the game.\nüü£ Drag and drop the right shape!\n\nüè° Press 'Return to Home' to go back.",
        width / 2, height / 2
    );
    drawBackButton();
}

// ----------------------
// üü£ Shape Drag & Drop Game
// ----------------------
function shuffleArray(arr) {
    let a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
        let j = floor(random(i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}

function startShapeDragGame() {
    // Hide completion buttons in case they exist
    hideCompletionButtons();

    dragShapes = [];
    let startX = 120;
    let spacing = 90;

    for (let i = 0; i < shapeList.length; i++) {
        let s = {
            type: shapeList[i],
            x: startX + i * spacing,
            y: 180,
            homeX: startX + i * spacing,
            homeY: 180,
            size: 70,
            color: color(random(100, 255), random(100, 255), random(100, 255)),
            returning: false,
            shakeTimer: 0,
            locked: false
        };
        dragShapes.push(s);
    }

    targetsQueue = shuffleArray(shapeList);
    targetShape = targetsQueue.length ? targetsQueue[0] : "";
    draggedShape = null;
    feedbackMsg = "";
    feedbackTimer = 0;
    correctAttempts = 0;
    totalAttempts = 0;
    gameFinished = false;

    // Make sure screen and DOM buttons are consistent
    screen = "dragdrop";
    for (let k in buttons) buttons[k].hide();
    hideCompletionButtons();
}

function drawShapeDragGame() {
    drawGarden();

    textAlign(CENTER);
    textFont(fontRegular);
    fill("#7a0043");
    textSize(32);
    text("üü£ Shape Drag & Drop üü£", width / 2, 60);
    textSize(18);
    fill("#7a0043");
    text(`Correct: ${correctAttempts} / Attempts: ${totalAttempts}`, width - 300, 90);

    // Update & draw shapes
    for (let s of dragShapes) updateShapeAnimation(s);
    for (let s of dragShapes) drawShape(s);

    // Target box
    fill("#fff6f8"); stroke("#ff8ba0"); strokeWeight(3);
    rectMode(CENTER);
    rect(width / 2, height - 80, 180, 100, 20);
    noStroke(); fill("#7a0043"); textSize(20);
    text((targetShape || "") + " here! --->", width / 4.5, height - 80);

    // Feedback
    if (feedbackTimer > 0) {
        fill(feedbackColor);
        textSize(24);
        text(feedbackMsg, width / 2, 120);
        feedbackTimer--;
    }

    drawBackButton();
}

// ----------------------
// Shape Animations
// ----------------------
function updateShapeAnimation(s) {
    if (s.locked) {
        // Keep locked ones near the target area
        // if we set home to target, position them there
        s.x = lerp(s.x, s.homeX, 0.12);
        s.y = lerp(s.y, s.homeY, 0.12);
        s.returning = false; s.shakeTimer = 0;
        return;
    }

    if (s.returning) {
        s.x = lerp(s.x, s.homeX, 0.22);
        s.y = lerp(s.y, s.homeY, 0.22);

        if (abs(s.x - s.homeX) < 0.5 && abs(s.y - s.homeY) < 0.5) {
            s.x = s.homeX; s.y = s.homeY; s.returning = false; s.shakeTimer = 0;
        } else if (s.shakeTimer > 0) s.shakeTimer--;
    }

    if (!draggedShape && !s.returning && !s.locked) {
        s.x = lerp(s.x, s.homeX, 0.08);
        s.y = lerp(s.y, s.homeY, 0.08);
    }
}

function drawShape(s) {
    push(); translate(s.x, s.y);
    let shakeX = 0, shakeY = 0;
    if (s.shakeTimer > 0) {
        shakeX = random(-4, 4); shakeY = random(-2, 2);
    }
    translate(shakeX, shakeY);
    noStroke(); fill(s.color);

    if (s.type === "circle") ellipse(0, 0, s.size);
    else if (s.type === "square") { rectMode(CENTER); rect(0, 0, s.size, s.size, 10); }
    else if (s.type === "triangle") triangle(0, -s.size / 2, -s.size / 2, s.size / 2, s.size / 2, s.size / 2);
    else if (s.type === "star") drawStar(0, 0, s.size / 3, s.size / 1.2, 5);
    else if (s.type === "heart") drawHeart(0, 0, s.size);

    pop();
}

function drawStar(x, y, r1, r2, n) {
    let angle = TWO_PI / n, half = angle / 2;
    beginShape();
    for (let a = 0; a < TWO_PI; a += angle) {
        vertex(x + cos(a) * r2, y + sin(a) * r2);
        vertex(x + cos(a + half) * r1, y + sin(a + half) * r1);
    }
    endShape(CLOSE);
}

function drawHeart(x, y, s) {
    beginShape();
    vertex(x, y + s / 4);
    bezierVertex(x - s / 2, y - s / 2, x - s, y + s / 3, x, y + s);
    bezierVertex(x + s, y + s / 3, x + s / 2, y - s / 2, x, y + s / 4);
    endShape(CLOSE);
}

function isMouseOverShape(s) {
    if (s.type === "circle") return dist(mouseX, mouseY, s.x, s.y) < s.size / 2;
    else if (s.type === "square") return mouseX > s.x - s.size / 2 && mouseX < s.x + s.size / 2 &&
        mouseY > s.y - s.size / 2 && mouseY < s.y + s.size / 2;
    else return dist(mouseX, mouseY, s.x, s.y) < s.size / 1.2;
}

function mouseDragged() {
    if (screen === "dragdrop" && draggedShape && !draggedShape.locked) {
        draggedShape.x = mouseX;
        draggedShape.y = mouseY;
        draggedShape.returning = false;
    }
}

function mouseReleased() {
    if (screen === "dragdrop" && draggedShape && !gameFinished) {
        let box = { x: width / 2, y: height - 80, w: 180, h: 100 };
        if (
            mouseX > box.x - box.w / 2 &&
            mouseX < box.x + box.w / 2 &&
            mouseY > box.y - box.h / 2 &&
            mouseY < box.y + box.h / 2
        ) {
            totalAttempts++;
            if (draggedShape.type === targetShape) {
                // Correct
                correctAttempts++;
                feedbackMsg = "‚úÖ Great job!"; feedbackColor = "green"; feedbackTimer = 120;
                // lock the shape near the target area (spread slightly)
                draggedShape.homeX = box.x + random(-40, 40);
                draggedShape.homeY = box.y + random(-10, 10);
                draggedShape.locked = true;
                draggedShape.returning = false;

                targetsQueue.shift();
                targetShape = targetsQueue.length ? targetsQueue[0] : "";

                if (!targetShape) {
                    // finished ‚Äî use a small delay then show completion UI
                    setTimeout(() => finishDragGame(), 300);
                }
            } else {
                // Wrong
                feedbackMsg = "‚ùå Try again!";
                feedbackColor = "red";
                feedbackTimer = 120;
                draggedShape.returning = true;
                draggedShape.shakeTimer = 30;
            }
        } else {
            draggedShape.returning = true;
        }
        draggedShape = null;
    }
}

// Called when the drag game is fully completed
function finishDragGame() {
    gameFinished = true;
    screen = "dragcomplete";
    showCompletionButtons();
}

// ----------------------
// Completion Buttons (use real p5 buttons so clicks always register)
// ----------------------
function showCompletionButtons() {
    hideCompletionButtons(); // ensure no duplicates

    // Return Home button
    completionHomeButton = createButton("üè° Return Home");
    completionHomeButton.size(140, 36);
    completionHomeButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFB6C1;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionHomeButton.position(width / 2 - 75 - 70, height - 120 + 10); // align with drawn visuals
    completionHomeButton.mousePressed(() => {
        resetBalloonGame();
        screen = "home";
        for (let k in buttons) buttons[k].show();
        hideCompletionButtons();
    });

    // Play Again button
    completionPlayAgainButton = createButton("üîÅ Play Again");
    completionPlayAgainButton.size(140, 36);
    completionPlayAgainButton.style("font-family:Comic Sans MS;font-size:16px;background:#FFD1DC;border-radius:10px;border:2px solid #ff8ba0;color:#7a0043;");
    completionPlayAgainButton.position(width / 2 + 75 - 70, height - 120 + 10);
    completionPlayAgainButton.mousePressed(() => {
        // Fully restart drag & drop
        startShapeDragGame();
        hideCompletionButtons();
        screen = "dragdrop";
    });
}

function hideCompletionButtons() {
    if (completionHomeButton) {
        completionHomeButton.remove();
        completionHomeButton = null;
    }
    if (completionPlayAgainButton) {
        completionPlayAgainButton.remove();
        completionPlayAgainButton = null;
    }
}

// ----------------------
// üéâ Completion Screen (visual only ‚Äî real buttons handle clicks)
// ----------------------
function drawDragComplete() {
    drawGarden();
    textAlign(CENTER); textFont(fontRegular);
    fill("#2e7d32"); textSize(36);
    text("üéâ Good Job! üéâ", width / 2, height / 2 - 40);
    textSize(20); fill("#7a0043");
    text(`You identified ${correctAttempts} shapes with ${totalAttempts} attempts.`, width / 2, height / 2);

}

// ----------------------
// End of sketch
// ----------------------
